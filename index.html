<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vistorias DIVIS - Lista de Processos</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffffff">
    <link rel="icon" href="icons/icon_128x128.png">

    <link rel="apple-touch-icon" href="icons/icon_128x128.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    
    <link rel="stylesheet" href="style.css"> 
    
    <style>
        .drag-process {
            cursor: grab;
        }
        .drag-process:active {
            cursor: grabbing;
        }
        /* Estilo para a célula de handle, se necessário */
        .drag-handle-cell {
            width: 30px; /* Garante que o handle não ocupe muito espaço */
            text-align: center;
        }
    </style>
</head>

<body class="bg-light">
    <div class="toast-container"></div>

    <div class="container-fluid mt-3">
        <div class="text-center mb-4">
            <h2 class="display-6">Lista de Processos</h2>
            <p class="text-muted">Visão geral das vistorias cadastradas</p>
        </div>

        <div class="form-section">
            <h4 class="section-title">
                <i class="bi bi-funnel me-2"></i>Opções de Filtragem e Ação
            </h4>
            <div class="row g-3 align-items-end">
                <div class="col-md-4">
                    <label for="filtroStatus" class="form-label">Filtrar por Status:</label>
                    <select class="form-select" id="filtroStatus">
                        <option value="">Todos os Status</option>
                        <option value="Pendente">Pendente</option>
                        <option value="Análise">Em Análise</option>
                        <option value="Vistoria">Em Vistoria</option>
                        <option value="Aprovado">Aprovado</option>
                        <option value="Reprovado">Reprovado</option>
                        <option value="Cancelado">Cancelado</option>
                        <option value="Não Realizada">Não Realizada</option>
                        <option value="Sem Status">Sem Status</option>
                        <option value="Concluído">Concluído</option> </select>
                </div>
                <div class="col-md-4">
                    <label for="filtroPesquisa" class="form-label">Pesquisar (Processo/Instituição):</label>
                    <input type="text" class="form-control" id="filtroPesquisa"
                        placeholder="Buscar número ou nome da instituição...">
                </div>
                <div class="col-md-4 d-flex justify-content-end">
                    <a href="processo.html" class="btn btn-primary">
                        <i class="bi bi-plus-circle me-2"></i>Novo Processo
                    </a>
                </div>
            </div>
        </div>

        <div id="listaContainer" class="row">
        </div>

        <div class="col-12 text-center text-muted p-5" id="noProcessesMessage" style="display: none;">
            <i class="bi bi-info-circle display-4 mb-3"></i>
            <h3>Nenhum processo encontrado.</h3>
            <p>Ajuste os filtros ou <a href="processo.html">adicione um novo processo</a> para vê-los aqui.</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script>
        // Chave do localStorage para salvar a ordem dos grupos (se necessário, mantida como fallback)
        const LOCAL_STORAGE_GROUP_ORDER_KEY = 'vistorias_process_status_group_order';
        // Prefixo para salvar a ordem dos processos *dentro* de cada status
        const LOCAL_STORAGE_ITEM_ORDER_PREFIX = 'vistorias_process_item_order_'; 


        /**
         * Retorna a ordem de status salva no localStorage ou a ordem padrão se não houver nenhuma.
         * (Mantida para manter a ordenação dos cards de grupo, mas não é estritamente necessária para a ordenação dos itens).
         * @returns {string[]} Um array com os nomes dos status na ordem desejada.
         */
        function getStatusOrder() {
            const defaultOrder = [
                "Sem Status", "Pendente", "Análise", "Vistoria", "Aprovado", 
                "Reprovado", "Não Realizada", "Cancelado", "Concluído"
            ];
            const savedOrderJson = localStorage.getItem(LOCAL_STORAGE_GROUP_ORDER_KEY);
            if (savedOrderJson) {
                try {
                    const savedOrder = JSON.parse(savedOrderJson);
                    const fullOrder = [...new Set([...savedOrder, ...defaultOrder])];
                    return fullOrder;
                } catch (e) {
                    return defaultOrder;
                }
            }
            return defaultOrder;
        }

        /**
         * Retorna a ordem salva dos processos (itens) para um status específico.
         * @param {string} statusKey - O status para o qual a ordem está sendo solicitada.
         * @returns {string[] | null} Um array de números de processo ou null.
         */
        function getItemOrder(statusKey) {
            try {
                const savedOrder = localStorage.getItem(LOCAL_STORAGE_ITEM_ORDER_PREFIX + statusKey);
                return savedOrder ? JSON.parse(savedOrder) : null;
            } catch (e) {
                console.error(`Erro ao ler ordem dos itens para ${statusKey}:`, e);
                return null;
            }
        }

        /**
         * Salva a nova ordem de processos (itens) para um status específico.
         * @param {string} statusKey - O status do grupo.
         * @param {string[]} newOrder - Array de números de processo na nova ordem.
         */
        function saveItemOrder(statusKey, newOrder) {
            try {
                localStorage.setItem(LOCAL_STORAGE_ITEM_ORDER_PREFIX + statusKey, JSON.stringify(newOrder));
                console.log(`Nova ordem de itens salva para ${statusKey}:`, newOrder);
            } catch (e) {
                console.error(`Erro ao salvar a ordem dos itens para ${statusKey}:`, e);
            }
        }


        /**
         * Gera uma classe CSS formatada para o status fornecido.
         * Remove acentos, espaços e caracteres especiais.
         * @param {string} status - O status do processo (ex: "Em Vistoria").
         * @returns {string} A classe CSS formatada (ex: "status-vistoria").
         */
        function formatarClasseStatus(status) {
            return 'status-' + status.toLowerCase()
                .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9\-]/g, '');
        }

        /**
         * Renderiza os cards de processos agrupados por status no HTML.
         * @param {Object} processosAgrupados - Objeto onde as chaves são os status e os valores são arrays de processos.
         */
        function renderizarProcessos(processosAgrupados) {
            const listaContainer = document.getElementById('listaContainer');
            if (!listaContainer) {
                console.error("Erro: Elemento com ID 'listaContainer' não encontrado!");
                return;
            }
            listaContainer.innerHTML = ''; 

            const ordenacaoStatus = getStatusOrder();
            const statusPresentes = Object.keys(processosAgrupados).filter(status => processosAgrupados[status].length > 0);
            let statusParaRenderizar = ordenacaoStatus.filter(status => statusPresentes.includes(status));
            statusPresentes.forEach(status => {
                if (!statusParaRenderizar.includes(status)) {
                    statusParaRenderizar.push(status);
                }
            });

            statusParaRenderizar.forEach(status => {
                let grupo = processosAgrupados[status];
                if (grupo && grupo.length > 0) {
                    const classStatus = formatarClasseStatus(status);
                    
                    // 1. Aplicar a ordem salva dos itens
                    const ordemSalva = getItemOrder(status);
                    if (ordemSalva) {
                        const mapaProcessos = new Map(grupo.map(p => [p.processo, p]));
                        const grupoOrdenado = [];
                        
                        // Adiciona processos na ordem salva
                        ordemSalva.forEach(processoNum => {
                            if (mapaProcessos.has(processoNum)) {
                                grupoOrdenado.push(mapaProcessos.get(processoNum));
                                mapaProcessos.delete(processoNum); // Remove do mapa
                            }
                        });

                        // Adiciona processos novos (que não estavam na ordem salva) no final
                        grupoOrdenado.push(...Array.from(mapaProcessos.values()));
                        grupo = grupoOrdenado; // Usa o grupo ordenado/atualizado
                    }

                    const card = document.createElement('div');
                    card.className = 'col-md-12 mb-4'; 
                    
                    // Renderiza as linhas dos processos
                    const tbodyContent = grupo.map(item => `
                        <tr class="drag-process" data-id="${item.processo}"> 
                            <td class="drag-handle-cell"><i class="bi bi-grip-vertical"></i></td>
                            <td><a href="processo.html?processo=${encodeURIComponent(item.processo)}">${item.processo}</a></td>
                            <td>${item.instituicao || "-"}</td>
                            <td>${item.inicio ? new Date(item.inicio).toLocaleString() : "-"}</td>
                            <td>${item.tipo || "-"}</td>
                            <td>${item.status || (item.status || "-")}</td> 
                        </tr>
                    `).join("");

                    // A tabela e o TBODY precisam ser criados para o Sortable
                    card.innerHTML = `
                        <div class="card shadow-sm">
                            <div class="card-header status-header ${classStatus}">
                                <h5 class="mb-0">${status} (${grupo.length} Processos)</h5>
                            </div>
                            <div class="card-body p-0">
                                <table class="table table-striped m-0">
                                    <thead class="table-light">
                                        <tr>
                                            <th class="drag-handle-cell"></th> <th>Processo</th>
                                            <th>Instituição</th>
                                            <th>Data de Início</th>
                                            <th>Tipo</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="sortable-list-${formatarClasseStatus(status)}" data-status-key="${status}">
                                        ${tbodyContent}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                    listaContainer.appendChild(card);
                    
                    // 2. Inicializa o Sortable em cada <tbody>
                    initializeSortable(document.getElementById(`sortable-list-${formatarClasseStatus(status)}`), status);
                }
            });
        }
        
        /**
         * Inicializa a funcionalidade de arrastar e soltar (SortableJS) em um tbody.
         * @param {HTMLElement} tbody - O elemento tbody que contém os itens arrastáveis.
         * @param {string} statusKey - O status do grupo para salvar a ordem.
         */
        function initializeSortable(tbody, statusKey) {
            new Sortable(tbody, {
                animation: 150, 
                handle: '.drag-handle-cell', // Apenas a célula com o ícone será arrastável
                onEnd: function (evt) {
                    // Obtém a nova ordem dos processos (os valores de data-id de cada TR)
                    const novaOrdem = Array.from(tbody.children)
                        .map(tr => tr.getAttribute('data-id'))
                        .filter(id => id !== null); 

                    // Salva a nova ordem no localStorage usando o status como chave
                    saveItemOrder(statusKey, novaOrdem);
                },
            });
        }


        /**
         * Carrega os processos do localStorage, aplica filtros e os exibe no HTML.
         */
        function carregarEExibirProcessos() {
            const processos = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('processo-')) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        if (data && data.processoBusca && data.instituicao) {
                            processos.push({
                                processo: data.processoBusca,
                                instituicao: data.instituicao,
                                inicio: data.inicio,
                                tipo: data.tipo,
                                status: data.status || "Sem Status", 
                                checkConcluido: data.checkConcluido 
                            });
                        } else {
                            console.warn(`Dados incompletos para a chave ${key}:`, data);
                        }
                    } catch (e) {
                        console.error(`Erro ao parsear dados do localStorage para a chave ${key}:`, e);
                    }
                }
            }

            const noProcessesMessage = document.getElementById('noProcessesMessage');
            // ... (Lógica de filtragem permanece a mesma) ...

            const searchTerm = document.getElementById('filtroPesquisa').value.toLowerCase();
            const filterStatus = document.getElementById('filtroStatus').value;
            const filterTipo = "";

            const processosFiltrados = processos.filter(p => {
                const matchesSearch = searchTerm === "" ||
                    p.processo.toLowerCase().includes(searchTerm) ||
                    p.instituicao.toLowerCase().includes(searchTerm);

                const statusProcesso = p.checkConcluido ? "Concluído" : (p.status || "Sem Status");
                const matchesStatus = filterStatus === "" || statusProcesso === filterStatus;
                const matchesTipo = filterTipo === "" || p.tipo === filterTipo;

                return matchesSearch && matchesStatus && matchesTipo;
            });

            // Agrupa os processos filtrados por status (chave de grupo para renderização/sortable)
            const agrupamentoPorStatus = {};
            processosFiltrados.forEach(p => {
                const statusKey = p.checkConcluido ? "Concluído" : (p.status || "Sem Status");
                if (!agrupamentoPorStatus[statusKey]) {
                    agrupamentoPorStatus[statusKey] = [];
                }
                agrupamentoPorStatus[statusKey].push(p);
            });

            if (noProcessesMessage) {
                if (processosFiltrados.length === 0) {
                    noProcessesMessage.style.display = 'block';
                } else {
                    noProcessesMessage.style.display = 'none';
                }
            }

            // Renderiza os processos e inicializa o Sortable para os itens
            renderizarProcessos(agrupamentoPorStatus);
        }

        // Adiciona event listeners quando o DOM estiver completamente carregado
        document.addEventListener('DOMContentLoaded', () => {
            carregarEExibirProcessos();

            const filtroPesquisa = document.getElementById('filtroPesquisa');
            if (filtroPesquisa) {
                filtroPesquisa.addEventListener('input', carregarEExibirProcessos);
            }

            const filtroStatus = document.getElementById('filtroStatus');
            if (filtroStatus) {
                filtroStatus.addEventListener('change', carregarEExibirProcessos);
            }
        });
    </script>
    <script>
    if ('serviceWorker' in navigator) {
    window.addEventListener('load', function () {
        navigator.serviceWorker.register('/sw.js').then(function (registration) {
        console.log('Service Worker registrado com sucesso:', registration.scope);
        }, function (err) {
        console.log('Erro ao registrar o Service Worker:', err);
        });
    });
    }
    </script>
</body>

</html>